# 리눅스 프로세스 구조

## 프로세스 개요

리눅스에서 프로세스는 실행 중인 프로그램의 인스턴스를 의미합니다. 각 프로세스는 독립된 메모리 공간을 가지며, 운영체제에 의해 관리되는 실행 단위입니다. 리눅스는 멀티태스킹 운영체제로서 여러 프로세스를 동시에 실행하고 관리할 수 있습니다.

## 프로세스 구조

### 프로세스 제어 블록 (PCB - Process Control Block)

운영체제는 각 프로세스마다 **프로세스 제어 블록**을 유지합니다. PCB는 프로세스의 모든 정보를 담고 있는 데이터 구조로, 프로세스 상태 관리와 컨텍스트 스위칭에 필수적입니다.

PCB에는 프로세스 ID(PID), 부모 프로세스 ID(PPID), 프로세스 상태, CPU 레지스터 값, 메모리 관리 정보, 파일 디스크립터 테이블, 우선순위, 프로그램 카운터 등이 포함됩니다.

### 메모리 구조

프로세스의 가상 메모리 공간은 여러 영역으로 나뉘어집니다.

**텍스트 영역(Code Segment)**은 실행 가능한 프로그램 코드가 저장되는 읽기 전용 영역입니다. 여러 프로세스가 같은 프로그램을 실행할 때 이 영역을 공유할 수 있어 메모리 효율성을 높입니다.

**데이터 영역**은 초기화된 전역 변수와 정적 변수들이 저장됩니다. 프로그램 컴파일 시점에 크기가 결정되며, 읽기/쓰기가 가능합니다.

**BSS 영역**은 초기화되지 않은 전역 변수와 정적 변수들이 위치합니다. 프로그램 실행 시 자동으로 0으로 초기화됩니다.

**힙 영역**은 동적 메모리 할당을 위한 공간입니다. malloc, calloc 등의 함수를 통해 런타임에 메모리를 할당하고 해제할 수 있으며, 프로그램 실행 중에 크기가 변할 수 있습니다.

**스택 영역**은 함수 호출과 지역 변수를 위한 공간입니다. 함수가 호출될 때마다 스택 프레임이 쌓이며, 함수가 종료되면 해당 프레임이 제거됩니다. 스택은 높은 주소에서 낮은 주소로 성장합니다.

## 프로세스 상태

### 프로세스 생명주기

리눅스 프로세스는 생성부터 소멸까지 여러 상태를 거치며 변화합니다.

**실행 상태(Running)**는 프로세스가 현재 CPU를 할당받아 실행 중인 상태입니다. 멀티코어 시스템에서는 여러 프로세스가 동시에 실행 상태가 될 수 있습니다.

**준비 상태(Ready)**는 실행할 준비가 완료되었지만 CPU 할당을 기다리는 상태입니다. 스케줄러에 의해 CPU가 할당되면 실행 상태로 전환됩니다.

**대기 상태(Waiting/Blocked)**는 입출력 작업이나 다른 이벤트를 기다리는 상태입니다. 디스크 읽기, 네트워크 응답, 사용자 입력 등을 대기할 때 이 상태가 됩니다.

**좀비 상태(Zombie)**는 프로세스가 종료되었지만 부모 프로세스가 아직 종료 상태를 확인하지 않은 상태입니다. 시스템 리소스는 대부분 해제되지만 PCB는 유지됩니다.

**고아 상태(Orphan)**는 부모 프로세스가 먼저 종료되어 init 프로세스(PID 1)가 새로운 부모가 된 프로세스입니다.

### 프로세스 우선순위

리눅스는 **Nice 값**을 통해 프로세스 우선순위를 관리합니다. Nice 값은 -20부터 19까지의 범위를 가지며, 낮은 값일수록 높은 우선순위를 의미합니다. 일반 사용자는 자신의 프로세스 우선순위를 낮출 수만 있고, root 권한이 있어야 우선순위를 높일 수 있습니다.

## 프로세스 생성과 실행

### fork() 시스템 호출

리눅스에서 새로운 프로세스는 기존 프로세스를 복제하는 방식으로 생성됩니다. **fork() 시스템 호출**은 현재 프로세스의 완전한 복사본을 만들어 자식 프로세스를 생성합니다.

fork() 호출 후 부모 프로세스에는 자식의 PID가 반환되고, 자식 프로세스에는 0이 반환됩니다. 이를 통해 부모와 자식이 서로 다른 코드 경로를 실행할 수 있습니다.

### exec() 계열 함수

fork()로 생성된 자식 프로세스는 종종 **exec() 계열 함수**를 호출하여 새로운 프로그램으로 교체됩니다. exec() 함수는 현재 프로세스의 메모리 이미지를 새로운 프로그램으로 완전히 대체합니다.

### Copy-on-Write (COW)

효율성을 위해 리눅스는 **Copy-on-Write 메커니즘**을 사용합니다. fork() 시점에는 실제로 메모리를 복사하지 않고 페이지를 공유하며, 실제로 메모리 수정이 발생할 때만 복사를 수행합니다. 이를 통해 메모리 사용량과 프로세스 생성 시간을 크게 줄일 수 있습니다.

## 프로세스 스케줄링

### 스케줄링 정책

리눅스는 여러 스케줄링 정책을 제공합니다.

**CFS(Completely Fair Scheduler)**는 기본 스케줄링 정책으로, 모든 프로세스에게 공평한 CPU 시간을 할당하려고 합니다. 가상 런타임을 기반으로 작동하며, 실제 실행 시간과 Nice 값을 고려하여 스케줄링 결정을 내립니다.

**실시간 스케줄링 정책**으로는 SCHED_FIFO와 SCHED_RR이 있습니다. SCHED_FIFO는 선입선출 방식으로, 높은 우선순위 프로세스가 완료될 때까지 선점되지 않습니다. SCHED_RR은 라운드 로빈 방식으로 동일한 우선순위 프로세스들 간에 시간 할당량을 순환합니다.

### 컨텍스트 스위칭

프로세스 간 전환 시 발생하는 **컨텍스트 스위칭**은 현재 프로세스의 상태를 저장하고 다음 프로세스의 상태를 복원하는 과정입니다. CPU 레지스터, 프로그램 카운터, 스택 포인터 등이 교체되며, 이는 상당한 오버헤드를 수반합니다.

## 프로세스 간 통신 (IPC)

### 파이프와 FIFO

**파이프**는 부모-자식 프로세스 간 단방향 통신을 제공합니다. 익명 파이프는 관련된 프로세스들만 사용할 수 있으며, **FIFO(Named Pipe)**는 파일 시스템에 이름을 가진 파이프로 무관한 프로세스들도 통신할 수 있습니다.

### 시그널

**시그널**은 프로세스에게 이벤트 발생을 알리는 소프트웨어 인터럽트입니다. SIGKILL, SIGTERM, SIGINT 등 다양한 시그널이 정의되어 있으며, 프로세스는 시그널 핸들러를 등록하여 특정 시그널에 대응할 수 있습니다.

### System V IPC

**공유 메모리**는 여러 프로세스가 동일한 메모리 영역을 공유하여 빠른 데이터 교환을 가능하게 합니다. **메시지 큐**는 구조화된 메시지를 프로세스 간에 전달하는 메커니즘입니다. **세마포어**는 공유 자원에 대한 접근을 제어하는 동기화 도구입니다.

### POSIX IPC

POSIX 표준을 따르는 IPC 메커니즘으로, 이식성이 뛰어나고 현대적인 설계를 가집니다. POSIX 세마포어, 메시지 큐, 공유 메모리 등이 포함됩니다.

## 스레드와 프로세스

### 리눅스 스레드 모델

리눅스는 **NPTL(Native POSIX Thread Library)**을 사용하여 스레드를 구현합니다. 리눅스에서 스레드는 경량 프로세스로 구현되며, clone() 시스템 호출을 통해 생성됩니다.

### 스레드 vs 프로세스

스레드는 같은 프로세스 내에서 메모리 공간을 공유하므로 생성 오버헤드가 적고 컨텍스트 스위칭이 빠릅니다. 하지만 메모리 공유로 인한 동기화 문제와 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있다는 단점이 있습니다.

프로세스는 독립된 메모리 공간을 가져 안정성이 높지만, 생성 비용이 크고 프로세스 간 통신이 복잡합니다.

## 프로세스 모니터링과 관리

### /proc 파일 시스템

리눅스는 **/proc 가상 파일 시스템**을 통해 실행 중인 프로세스들의 상세 정보를 제공합니다. /proc/[PID] 디렉터리에는 해당 프로세스의 메모리 맵, 파일 디스크립터, 환경 변수, 상태 정보 등이 파일 형태로 노출됩니다.

### 프로세스 제어

프로세스는 다양한 시그널을 통해 제어할 수 있습니다. SIGTERM은 정상 종료를 요청하고, SIGKILL은 강제 종료를 수행합니다. SIGSTOP과 SIGCONT는 프로세스를 일시 정지하고 재개할 수 있게 합니다.

### 리소스 제한

**ulimit**와 **cgroups**를 통해 프로세스의 리소스 사용을 제한할 수 있습니다. 메모리 사용량, 파일 디스크립터 수, CPU 시간 등을 제한하여 시스템 안정성을 보장할 수 있습니다.
