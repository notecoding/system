# 리눅스 프로세스 제어

## 프로세스 제어 개요

리눅스에서 프로세스 제어는 실행 중인 프로세스의 상태를 관리하고 조작하는 메커니즘을 의미합니다. 시스템 관리자와 사용자는 다양한 도구와 시그널을 통해 프로세스를 시작, 중지, 재개, 종료할 수 있으며, 프로세스의 우선순위와 자원 사용량을 조절할 수 있습니다.

## 시그널 기반 프로세스 제어

### 시그널의 개념

**시그널**은 프로세스에게 이벤트 발생을 알리는 소프트웨어 인터럽트입니다. 운영체제, 다른 프로세스, 또는 프로세스 자신이 시그널을 발생시킬 수 있으며, 각 시그널은 고유한 번호와 의미를 가집니다.

시그널은 비동기적으로 전달되며, 프로세스는 시그널을 받으면 현재 실행을 중단하고 시그널 처리를 수행합니다. 프로세스는 시그널에 대해 기본 동작을 수행하거나, 사용자 정의 핸들러를 실행하거나, 시그널을 무시할 수 있습니다.

### 주요 시그널

**SIGTERM (15)**은 프로세스에게 정상적인 종료를 요청하는 시그널입니다. 프로세스는 이 시그널을 받으면 정리 작업을 수행한 후 종료할 수 있습니다. 대부분의 프로그램은 SIGTERM을 받으면 현재 작업을 안전하게 마무리하고 종료합니다.

**SIGKILL (9)**은 프로세스를 즉시 강제 종료시키는 시그널입니다. 이 시그널은 무시하거나 처리할 수 없으며, 커널이 직접 프로세스를 종료합니다. 프로세스가 응답하지 않을 때 최후의 수단으로 사용됩니다.

**SIGINT (2)**는 인터럽트 시그널로, 일반적으로 Ctrl+C를 누를 때 발생합니다. 대화형 프로그램에서 사용자가 프로그램 실행을 중단하고자 할 때 사용됩니다.

**SIGSTOP (19)**과 **SIGCONT (18)**은 프로세스를 일시 정지하고 재개하는 시그널입니다. SIGSTOP은 무시할 수 없으며, 프로세스를 즉시 정지시킵니다. SIGCONT는 정지된 프로세스를 다시 실행 상태로 전환합니다.

**SIGHUP (1)**은 원래 터미널 연결이 끊어졌을 때 발생하는 시그널이지만, 현재는 설정 파일을 다시 읽도록 하는 용도로도 사용됩니다. 많은 데몬 프로세스들이 SIGHUP을 받으면 설정을 재로드합니다.

**SIGUSR1 (10)**과 **SIGUSR2 (12)**는 사용자 정의 시그널로, 프로그램별로 특별한 의미를 부여할 수 있습니다.

### 시그널 전송

**kill 명령어**는 프로세스에게 시그널을 전송하는 가장 기본적인 도구입니다. 프로세스 ID를 지정하여 특정 프로세스에게 시그널을 보낼 수 있으며, 시그널을 지정하지 않으면 기본적으로 SIGTERM을 전송합니다.

**killall 명령어**는 프로세스 이름을 기반으로 해당하는 모든 프로세스에게 시그널을 전송합니다. 동일한 이름의 여러 프로세스를 한 번에 제어할 때 유용합니다.

**pkill 명령어**는 더 유연한 프로세스 선택 기준을 제공합니다. 프로세스 이름, 사용자, 터미널 등 다양한 조건으로 프로세스를 선택하여 시그널을 전송할 수 있습니다.

## 작업 제어 (Job Control)

### 포어그라운드와 백그라운드

리눅스 셸에서 프로세스는 **포어그라운드**에서 실행되거나 **백그라운드**에서 실행될 수 있습니다. 포어그라운드 프로세스는 터미널의 입력을 받을 수 있고 출력을 터미널에 직접 표시하지만, 백그라운드 프로세스는 터미널과 상호작용하지 않고 독립적으로 실행됩니다.

명령어 뒤에 **&(앰퍼샌드)**를 붙이면 해당 프로세스가 백그라운드에서 실행됩니다. 셸은 즉시 명령 프롬프트를 표시하여 다른 명령을 입력할 수 있게 합니다.

### 작업 일시정지와 재개

실행 중인 포어그라운드 프로세스는 **Ctrl+Z**를 눌러 일시정지할 수 있습니다. 이때 프로세스는 SIGTSTP 시그널을 받고 정지 상태가 됩니다.

**jobs 명령어**는 현재 셸에서 관리하는 모든 작업의 목록을 표시합니다. 각 작업에는 작업 번호가 할당되며, 상태 정보와 함께 표시됩니다.

**fg 명령어**는 백그라운드나 정지된 작업을 포어그라운드로 가져옵니다. **bg 명령어**는 정지된 작업을 백그라운드에서 재개합니다.

**nohup 명령어**는 터미널 세션이 끝나도 프로세스가 계속 실행되도록 합니다. SIGHUP 시그널을 무시하고 표준 출력을 파일로 리다이렉트하여 터미널과 독립적으로 실행됩니다.

## 프로세스 우선순위 제어

### Nice 값과 우선순위

리눅스는 **Nice 값**을 통해 프로세스의 스케줄링 우선순위를 제어합니다. Nice 값의 범위는 -20부터 19까지이며, 낮은 값일수록 높은 우선순위를 의미합니다.

기본 Nice 값은 0이며, 일반 사용자는 자신의 프로세스 Nice 값을 증가시킬 수만 있습니다(우선순위를 낮춤). 관리자 권한이 있어야 Nice 값을 감소시켜 우선순위를 높일 수 있습니다.

**nice 명령어**는 프로세스를 시작할 때 Nice 값을 지정합니다. **renice 명령어**는 실행 중인 프로세스의 Nice 값을 변경합니다.

### 실시간 우선순위

일반적인 Nice 값 외에도 리눅스는 **실시간 스케줄링**을 지원합니다. 실시간 프로세스는 일반 프로세스보다 항상 높은 우선순위를 가지며, 더 예측 가능한 응답 시간을 제공합니다.

실시간 스케줄링 정책으로는 SCHED_FIFO와 SCHED_RR이 있으며, 실시간 우선순위는 1부터 99까지의 범위를 가집니다. 높은 숫자일수록 높은 우선순위를 의미합니다.

## 프로세스 모니터링

### 프로세스 상태 확인

**ps 명령어**는 현재 실행 중인 프로세스들의 정보를 표시합니다. 다양한 옵션을 통해 모든 프로세스, 특정 사용자의 프로세스, 또는 특정 조건을 만족하는 프로세스들을 선택적으로 볼 수 있습니다.

**top 명령어**는 실시간으로 시스템의 프로세스 상태를 모니터링합니다. CPU 사용률, 메모리 사용률, 프로세스 목록을 동적으로 업데이트하여 표시하며, 대화형 인터페이스를 통해 프로세스를 제어할 수 있습니다.

**htop**은 top의 향상된 버전으로, 더 직관적인 인터페이스와 추가 기능을 제공합니다. 트리 뷰, 색상 표시, 마우스 지원 등을 통해 더 편리한 프로세스 모니터링이 가능합니다.

### 프로세스 트리 구조

**pstree 명령어**는 프로세스들의 부모-자식 관계를 트리 형태로 표시합니다. 프로세스 간의 계층 구조를 이해하고, 관련된 프로세스들을 파악하는 데 유용합니다.

**pgrep 명령어**는 특정 조건에 맞는 프로세스의 PID를 찾습니다. 프로세스 이름, 사용자, 부모 프로세스 등을 기준으로 검색할 수 있습니다.

## 고급 프로세스 제어

### 프로세스 그룹과 세션

리눅스는 관련된 프로세스들을 **프로세스 그룹**으로 묶어 관리합니다. 파이프라인으로 연결된 명령들이나 작업 제어에서 함께 다뤄져야 하는 프로세스들이 같은 그룹에 속합니다.

**세션**은 하나 이상의 프로세스 그룹을 포함하는 더 큰 단위입니다. 일반적으로 로그인 세션과 연관되며, 터미널과의 연결을 관리합니다.

### 시그널 마스킹과 처리

프로세스는 특정 시그널을 **차단(block)**하여 나중에 처리하거나, **무시(ignore)**하도록 설정할 수 있습니다. 이를 통해 중요한 작업 중에 인터럽트를 방지하거나, 특정 시그널에 대한 사용자 정의 처리를 구현할 수 있습니다.

**시그널 핸들러**는 시그널이 발생했을 때 실행되는 함수입니다. 프로그램은 시그널 핸들러를 등록하여 시그널에 대한 사용자 정의 응답을 구현할 수 있습니다.

### 데몬 프로세스 제어

**데몬 프로세스**는 백그라운드에서 지속적으로 실행되는 시스템 서비스입니다. 일반적으로 시스템 부팅 시 시작되며, 특정 서비스를 제공하기 위해 계속 실행됩니다.

**systemd**는 현대 리눅스 배포판에서 사용되는 init 시스템 및 서비스 관리자입니다. systemctl 명령어를 통해 서비스의 시작, 중지, 재시작, 상태 확인 등을 수행할 수 있습니다.

전통적인 **System V init** 시스템에서는 /etc/init.d 디렉터리의 스크립트를 통해 서비스를 관리했으며, service 명령어나 직접 스크립트 실행을 통해 제어했습니다.

## 리소스 제한과 제어

### ulimit을 통한 리소스 제한

**ulimit**는 셸과 그 자식 프로세스들의 리소스 사용을 제한하는 내장 명령입니다. 파일 크기, 메모리 사용량, 프로세스 수, 파일 디스크립터 수 등을 제한할 수 있습니다.

하드 리미트는 관리자만 변경할 수 있는 절대적 한계이며, 소프트 리미트는 사용자가 하드 리미트 내에서 조정할 수 있는 현재 한계입니다.

### cgroups를 통한 고급 리소스 제어

**Control Groups(cgroups)**는 프로세스 그룹의 리소스 사용을 제한하고 격리하는 리눅스 커널 기능입니다. CPU 시간, 메모리, 네트워크 대역폭, 디스크 I/O 등을 세밀하게 제어할 수 있습니다.

cgroups는 계층적 구조를 가지며, 컨테이너 기술의 기반이 됩니다. Docker와 같은 컨테이너 런타임은 cgroups를 사용하여 컨테이너별 리소스 격리와 제한을 구현합니다.

### 프로세스 어피니티 제어

**CPU 어피니티**는 특정 프로세스가 실행될 수 있는 CPU 코어를 제한하는 기능입니다. **taskset 명령어**를 사용하여 프로세스의 CPU 어피니티를 설정하거나 확인할 수 있습니다.

멀티코어 시스템에서 프로세스를 특정 코어에 바인딩하면 캐시 지역성을 향상시키고 성능을 최적화할 수 있습니다. 반대로 부하 분산을 위해 프로세스를 여러 코어에 분산시킬 수도 있습니다.
